---
title: 数据链路层的流量控制和可靠传输
time: 2023/03/24
category: 计算机网络
description: 数据链路层第四部分,GBN,小总结
---



### 后退N帧协议（GBN）

WR=1,WT<=2^n - 1

因为停止等待协议太浪费时间了，所以尝试采用GBN，发送连续多个数据帧，以增大信道利用率
注释：
累计确认：就是收到一个确认帧，那么**它和它之前的所有帧**都默认已收到，反之，如果某个确认帧没收到，那么**它和它之后的所有帧**都默认丢失（即使收到了也丢掉），进行重传

![image-20230406192332294](https://cdn.jsdelivr.net/gh/gdlearncoding/blogImage@main/202304061923405.png)

发送窗口不能无限大，与使用的编号的比特数有关，二进制表示。
2比特编号0-3，二进制表示就是00，01，10，11。如果要5个窗口长度，那么窗口内数据编号都编不过来，直接乱套了

GBN的优缺点也显而易见，优点是相对于上面的停止等待协议，明显提高了信道利用率，缺点是因为重传机制的原因，导致已经收到数据却需要强行丢弃(接收端只有一个缓存)，进而造成浪费

### 选择重传协议（ARQ or SR）

WT=WR=2^(n-1)

吸取了GBN协议的教训，我们打算尝试`只重传错误的帧`，这样的话就不用浪费资源把已经收到的帧再重传一次了。

在GBN中，仅有接收端有一个窗口来存放数据帧，在SR中，两者都有窗口了。
和GBN的区别其实就是做了`一个数据缓存，已经收到的帧不用扔了`，等待之前因意外丢失的帧收到的时候确认即可，但是只能缓存窗口尺寸内的包含的帧（注释：缓存不可能无限大）

SR运行过程

注释：2帧丢失之后仍然在发送，但是2帧丢失之后只是缓存，并没有移动窗口；它可以继续接受窗口范围内排在2帧后面的数据帧，直至最后2帧收到后一次性确认窗口内的所有已经收到的帧，再移动窗口。

![image-20230406192733401](https://cdn.jsdelivr.net/gh/gdlearncoding/blogImage@main/202304061927480.png)

