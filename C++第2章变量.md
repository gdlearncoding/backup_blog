---
title: 变量和基本类型
category: C++
time: 2023/03/01
description:  C++ Primer第二章
---

# 变量和基本类型

## 基本内置类型

### 算数类型和空类型

- 其他整型都有两种(i,ui),char有三种,其中char自己就算一种,具体由编译器决定

### 字面值常量

#### 整型和浮点型字面值

- 每个字面值常量都对应一种数据类型,其==形式和值==决定了它的数据类型

- 如果一个字面值连与之关联的最大的数据类型都放不下,将产生错误

- 十进制字面值是带符号数,八进制和十六进制可能是带符号的也可能是不带符号的

- eg:当一个程序内出现出现整型字面值时，他是属于整形家族9种不同数据中的哪一种（int，long,long long long,char）？

       其实我们可以在这些字面值后面添加一个后缀来改变缺省的规则，比如123L(或其小写)表明其是长整型，123u（或123U）等等。
          
          当然，如果没有添加后缀，即其处在缺省的状态，那么它是能容纳整个整型中的最短整型。

#### 字符和字符串字面值

- 单引号引起来的一个字符称为char型字面值,双引号括起来的==零个或多个字符==则构成字符串型字面值
- 双引号引起来的后面定有‘\0’
- 转义序列:不可打印或有特殊含义(单引号等)
- 指定字面值的类型:添加前缀或后缀

#### 布尔字面值和指针字面值

- true和false
- nullptr

## 变量

一个具名的,可提供程序操作的存储空间.与对象一般可以互换使用

### 定义

类型说明符+一个或多个变量名

### 初始值

初始化:对象在==创建==的时候获得的一个特定的值,==不等同于赋值==

#### 列表初始化

```c++
int i = 0;	//存在丢失信息时,转换,丢失部分值
int i = {0};//存在丢失信息时,报错,编译器拒绝
int i{0};	//存在丢失信息时,报错,编译器拒绝
int i(0);	//存在丢失信息时,转换,丢失部分值
```

==C++11==让花括号得到全面应用(之前是受限的)

注意==类型转换==问题,不然可能出bug

#### 默认初始化

##### 内置类型

- 定义在任何函数体外	0
- 定义在函数内         ==不被初始化==

##### 每个类

由自己决定

### 声明和定义

前提:C++支持分离式编译

#### 声明:使名字为程序所知

只声明不定义:==extern==

```c++
externa int i;//声明而不定义
external int k = 1;//定义
```

#### 定义:负责创建与名字有关的实体

变量==能且只能被定义一次==

### 标识符

- 字母,数字,下划线.只能用字母或下划线开头

- 变量名小写
- 自定义类名用大写字母开头

### 作用域

- 全局作用域:所有花括号外
- 块作用域

#### 嵌套的作用域

内层可以使用外层作用域的声明

发生==重复==时使用的是==正在作用域内的局部变量==!

## 复合类型

### 引用

- ==并非对象==,只是==别名==,将引用与初始值==绑定==在一起

- 引用必须==初始化==,且初始值必须是一个对象
- 没有引用的引用

```c++
int i = 12;
int &refi = i, i2 = i;//refi是引用,i2是int
int k = refi;	//k=12
```

### 指针

void*可用于存放任意对象的地址

不能直接操作void*指针所指向的对象(因为不知道类型)

### 类型修饰符不过是声明符的一部分

```c++
int i= 12,*ptri = &i, &refi = i;
//基本数据类型只有一个,声明符的形式在变化
```

变量的定义:基本数据类型和一组声明符

## const 限定符

- const对象一旦被创建后值就不能改变,所以==必须初始化==(要不然没用了)

- const对象被设定在==仅文件内有效==,多个文件内出现同名等于分别定义独立的变量.解决办法(都用一个变量):不管是声明还是定义都加extern

- 对const的引用简称常量引用

### 指针和const
- 指向常量的指针不能用于改变其所指对象的值
- 想要存放常量对象的地址，只能使用指向常量的指针
- 把指针定义为常量（常量指针）必须初始化，其指向的地址不能再变了
```c++
const int pi = 3;
int *ptr1 = &pi; //wrong, ptr1 is not a const int
int *ptr2 = &pi; //right
*ptr2 = 4;//wrong,pi is const
int other = 5;
ptr2 = &other; //right,ptr2 is not a const int

int *const ptr3 = &other;//right,ptr3 is const,must init
ptr3 = &pi; //wrong
other = 6;//right

const int *const ptr4 = pi;//指向常量对象的常量指针,左边为底层，右边为顶层
```
指针本身是不是常量与指针所指的是不是一个常量是两个相互独立的问题
### 顶层const
> 顶层const：指针本身是个常量|任意对象是常量
> 底层const：指针所指的对象是一个常量|与复合类型的基本类型部分相关
不能改变自身的值->顶层const

不能改变所指对象的值->底层const
```c++
const int c = 1;//c的值不能改变，顶层const
const int &r = c;//用于声明引用的const都是底层const
```
### constexpr和常量表达式

常量表达式:值不会改变并且在编译过程中就能得到的计算结果的表达式

C++11规定将变量声明为constexpr类型一遍遍一起验证是否是一个常量表达式

```c++
constexpr int i = size();//只有size是一个constexpr函数才正确
```

constexpr只对指针有效,对其所指的对象无效

```c++
const int *p = nullptr; // P 是一个指向整型常量的指针
constexpr int *q = nullptr; // q是一个指向整数的常量指针
```

## 处理类型

### 类型别名

别名和名字等价

#### typedef

```c++
typedef wages base, *p;
//base是double 的同义词，p 是double*的同义词

typedef char *pstring;//*是char的
const pstring cstr = 0; // cstr 是指向 char 的常量指针
const pstring *ps; //ps 是一个指针，它的对象是指向char的常量指针
```

#### 别名声明 using

```c++
using SI = Sales_item;
//SI是别名,用来定义类型
```

### auto类型说明符

让编译器通过初始值推算变量的类型,因此auto定义的变量必须有初始值

一般会忽略顶层const,保留底层const

如果需要推断出顶层,要明确在前面加上const

要在一条语句中定义多个变量，切记，==符号&和*只从属于某个声明符==，而非基本数据类型的一部分，

### decltype类型指示符

选择并返回操作数的数据类型

```c++
decltype(f()) sum = x;//sum类型就是f的返回类型,但并不调用f

const int ci = 0, &cj = ci;
decltype(ci) x = 0; //x的类型是 const int
decltype(cj) y = x; //y的类型是 const int&，y 绑定到变量x
decltype(cj) z; 	// 错误：z 是一个引用，必须初始化

int i = 42, *p = &i, &r = i;
decltype(r + 0) b；// 正确：加法的结果是 int，因此b是一个（未初始化的）int
decltype(*p) c;//错误：c是*p = &i返回值,为int&，必须初始化

// decltype 的表达式如果是加上了括号的变量，结果将是引用
decltype((i)) d; // 错误：d 是 int&，必须初始化
decltype(i) e; //正确：e 是一个（未初始化的）int
```

如果 decltype 使用的表达式不是一个变量，则 decltype 返回表达式结果对应的类型。

decltype((variable))结果永远是**引用**!

## 自定义数据结构

类定义后面记得加分号

### struct

与C一样,等学到class再说

### 编写头文件

预处理,头文件保护符,预处理变量有两种状态:已定义和未定义

#define 指令把一个名字设定为预处理变量.

另外两个指令则分别检查某个指定的预处理变量是否已经定义：#ifdef 当且仅当变量已定义时为真，#ifndef 当且仅当变量未定义时为真。

一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。

**预处理变量无视C++语言中关于作用于的限制**