---
title: 运算方法和运算器
time: 2023/03/05
category: 计算机组成原理
description: 计算机组成原理第二章,包含进制转换,定点原码补码反码,加减乘除,浮点表示,运算
---

# 运算方法和运算器

## 数据与文字的表示

 计算机中使用的数据可分成两大类:

- **符号数据**:非数字符号的表示（ASCII、汉字、图形等）
- **数值数据**:数字数据的表示方式（定点、浮点）

### 数据格式

#### 10进制与R进制转换

1. 整数部分：除r取余，r为进制基数
2. 小数部分：乘r取整

#### 数据表示格式

- 定点表示：小数点位置固定
  - 所有数据的小数点位置固定不变
  - 理论上位置可以任意，但实际上将数据表示有两种**方法**（小数点位置固定-定点表示法）：
  - 纯小数：固定在**数据最高位**之前,不需要专门的存放位置
  - 纯整数：固定在**数据最低位**之后, 不需要专门的存放位置
- 定点缺点： 定点数表示数的范围受字长限制，表示数的范围有限;
  - 定点表示的精度有限
  - 机器中，常用定点**纯整数**表示;
  - 不能够表示实数范围内的所有数
- 浮点表示：小数点位置不固定
- 十进制数串:字符串,BCD(8421码)
- 字符和字符串:ASCII(低7位用来编码(128),最高位为校验位)等
- 汉字  输入编码、汉字内码、字模码分别是计算机用于输入、内部处理、输出三种不同用途的编码

![image-20230305134153170](https://cdn.jsdelivr.net/gh/gdlearncoding/blogImage@main/202303051959845.png)

![image-20230305134319970](https://cdn.jsdelivr.net/gh/gdlearncoding/blogImage@main/202303051959846.png)

- 校验码 异或,奇校验位:奇数个1,C = 0;偶校验位:偶数个1,C = 0

将一个字X从部件A传送到部件B，采用偶校验

![image-20230305134711168](https://cdn.jsdelivr.net/gh/gdlearncoding/blogImage@main/202303051959847.png)

### 数据的存储和排列顺序

- 对齐
- 大小端

![image-20230305133949197](https://cdn.jsdelivr.net/gh/gdlearncoding/blogImage@main/202303051959848.png)

### 数的机器码表示

真值:一般书写的数

机器码:机器中表示的数, 要解决在计算机内部数的正、负符号和小数点运算问题。

一共n+1位,xn为符号位

| 类型 | 最高位(符号位) | 正数          | 负数                       | 最小值               | 最大值            | 正负零               |
| ---- | -------------- | ------------- | -------------------------- | -------------------- | ----------------- | -------------------- |
| 原码 | 正数0负数1     | 0绝对值二进制 | 1 绝对值二进制             | 全1,**-(2^n - 1)**   | 01111,**2^n - 1** | **-0=1000  +0=0000** |
| 补码 | >=0,0;<0,1     | 0绝对值二进制 | 1 绝对值二进制**取反**`+1` | 10000,-2n            | 01111,2n-1        | **-0=0000  +0=0000** |
| 反码 | 正数0负数1     | 0绝对值二进制 | 1 绝对值二进制**取反**     | 10000,**-(2^n - 1)** | 全0,**2^n - 1**   | **-0=1111  +0=0000** |
| 移码 | >=0,1;<0,0     |               |                            |                      |                   |                      |

**对于一个`正数`来说：二进制原码、反码、补码是同一个，`完全相同`**

**对于一个`负数`来说:原码(`符号位为1`),反码（`符号位不变，其它位取反`）补码（`反码+1`）**

#### 原码

![image-20230305131454202](https://cdn.jsdelivr.net/gh/gdlearncoding/blogImage@main/202303051959849.png)

有正0和负0之分

范围 1-2n~2n–1

x=+1001,则 [x]原=01001

x=-1001,则[-x]原=11001

表示简单，易于同真值之间进行转换，实现乘除运算规则简单。

进行加减运算十分麻烦

#### 反码

正数的表示与原、补码相同，负数的反码符号位为1，数值位是将原码的数值按位取反，就得到该数的反码表示

电路容易实现，触发器的输出有正负之分

对尾数求反，它跟补码的区别在于末位少加一个1  [x]补=[x]反 + 1

![image-20230305132132418](https://cdn.jsdelivr.net/gh/gdlearncoding/blogImage@main/202303051959850.png)

#### 补码

补码是在“模”和“同余”的概念下导出的,在模为12的情况下，-2的补码 就是10。一个负数用其补码代替，同样可以得到正确的运算结果。

正数的补码就是正数的本身，负数的补码是原负数加上模

高位表明正负,无正零和负零之分

范围-2n~2n-1(定点整数）

![image-20230305132232486](https://cdn.jsdelivr.net/gh/gdlearncoding/blogImage@main/202303051959851.png)

最大的优点就是**将减法运算转换成加法运算**:

[X]补-[Y]补= [X]补+[-Y]补

正数：符号位为0，数值部分不变
负数：符号位为1，数值部分“各位取反，末位加1”

#### 移码

移码和补码尾数相同，符号位相反

范围:-2n~2n-1

Excess (biased) notion- 移码表示:将==每一个数值加上==一个偏置常数（ Excess / bias）

当编码位数为 n时，bias取 ==2n-1==

#### 用补码表示带符号整数原因

补码运算系统是模运算系统，加、减运算统一

数0的表示惟一，方便使用

比原码和反码多表示一个最小负数

与移码相比，其符号位和真值的符号对应关系清楚

### 浮点表示

有正零和负零之分,当阶码E为全0且尾数M也为全0时,

也有+∞和-∞之分,当阶码E为全1且尾数M为全0时

![image-20230305133251206](https://cdn.jsdelivr.net/gh/gdlearncoding/blogImage@main/202303051959852.png)

![image-20230305133020933](https://cdn.jsdelivr.net/gh/gdlearncoding/blogImage@main/202303051959853.png)

![image-20230305133043783](https://cdn.jsdelivr.net/gh/gdlearncoding/blogImage@main/202303051959854.png)

![image-20230305133102011](https://cdn.jsdelivr.net/gh/gdlearncoding/blogImage@main/202303051959855.png)

## 定点加减法

### 补码加法

[x+y]补= [x]补+[y]补（mod 2n+1）

在模2n+1意义下，任意两数的补码之和等于该两数之和的补码。

### 补码减法

[x-y]补= [x]补- [y]补= [x]补+[-y]补

从 [y]补到[-y]补的变换，只需要把[y]补连带符号位取反，末位再加1即可。

### 溢出的检测

左右为两个例子:

![image-20230305135525878](https://cdn.jsdelivr.net/gh/gdlearncoding/blogImage@main/202303051959856.png)

