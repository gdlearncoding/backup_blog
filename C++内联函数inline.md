---
title: inline内联函数
category: C++
time: 2023/04/11
description: 用法,说明,好处
---

## 内联函数

### 定义: 

当函数被声明为内联函数之后, 编译器会将其内联`展开`, 而不是按通常的函数调用机制进行调用.

在类体内定义的函数会被编译器自动声明为内联函数。

在函数定义前冠以关键字`inline`，该函数就被定义为**内联函数**。每当程序中出现对该函数的调用时，C++编译器使用函数体中的代码插入到调用该函数的语句之处，同时使用实参代替形参，以便在程序运行时不再进行函数调用。引入[内联函数](https://so.csdn.net/so/search?q=内联函数&spm=1001.2101.3001.7020)主要是为了==消除调用函数时的系统开销，以提高运行速度==。

```c++
#include <iostream>
using namespace std;

inline double circle(double r)  //内联函数
{
	double PI = 3.14;
	return PI * r * r;
}

int main() 
{
	for (int i = 1; i <= 3; i++)
		cout << "r = " << i << " area = " << circle(i) << endl;
	return 0;
}

```

### **说明**：

- 内联函数在第一次被调用之前必须进行完整的定义，否则编译器将无法知道应该插入什么代码
- 在内联函数体内一般不能含有复杂的控制语句，如for语句和switch语句等
- 使用内联函数是一种空间换时间的措施，若内联函数较长，较复杂且调用较为频繁时不建议使用 ,Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.

也就是用前定义,复杂不用

好处:

消除调用函数时的系统开销，以提高运行速度

**使用内联函数替代宏定义，能消除宏定义的不安全性**

缺点: 

滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, `小巧的代码往往执行更快`。

结论: 

一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!

### 内联函数和宏定义的区别

宏基本在C++中废掉了

1. 宏由预处理器在预处理阶段展开,内联函数是由编译器控制的。
2. 在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。
3. 内联函数是函数,可以进行诸如类型安全检查、语句是否正确等编译功能。宏不是函数,不具有这样的功能。
4. 内联函数在运行时可调试，宏定义不可以。

### -inl.h文件：


Tip： 复杂的内联函数的定义, 应放在后缀名为 -inl.h 的头文件中.


内联函数的定义必须放在头文件中, 编译器才能在调用点内联展开定义. 然而, 实现代码理论上应该放在 .cc 文件中, 我们不希望 .h 文件中有太多实现代码, 除非在可读性和性能上有明显优势.

如果内联函数的定义比较短小, 逻辑比较简单, 实现代码放在 .h 文件里没有任何问题. 比如, 存取函数的实现理所当然都应该放在类定义内. 出于编写者和调用者的方便, 较复杂的内联函数也可以放到 .h 文件中, 如果你觉得这样会使头文件显得笨重, 也可以把它萃取到单独的 -inl.h 中. 这样把实现和类定义分离开来, 当需要时包含对应的 -inl.h 即可。